\section{La Simulación}

Como planteamos en el capítulo anterior, se quiere desarrollar un programa que permita la simulación de enfrentamientos bélicos entre dos o más bandos.

Para esto se tienen pensado los siguientes aspectos que van a ser fijos en cada una de las simulaciones:

\begin{enumerate}
	\item La existencia de un mapa o terreno donde se producirá el enfrentamiento. Este tendrá propiedades que se serán modificables como las dimensiones, el relieve, la hidrografía, etc. La idea es que este se represente por una matriz bidimensional.
	
	\item Las acciones serán por turnos. Como tenemos dos bandos les llamaremos: bando A y bando B. En el turno del bando A cada una de las unidades de A realizará una y solo una acción (ya sea moverse hacia otra posición, atacar o mantener la posición). Luego de esto se pasará al turno del bando B, que al igual que A, podrá hacer una y solo una acción con cada una de sus unidades. Esta forma de implementación permite un comportamiento de acción-reacción entre los dos bandos, asemejándose a lo que ocurre en la vida real.
	
\end{enumerate}

\subsection{El mapa}

El mapa consiste en una matriz bidimensional de $m$ filas y $n$ columnas. Cada objeto de la matriz es un objeto \verb|Cell|. Un objeto \verb|Cell| representa cada una de las casillas que conforman el mapa y tiene los siguientes atributos:

\begin{itemize}
	\item \verb|passable|: Valor entre 0 y 10 que indica cuan accesible es una celda. Las unidades tienden a buscar las celdas que tengan este parámetro lo más alto posible, pues mientras mayor sea este valor, pueden hacer ataques más poderosos.
	\item \verb|row|: Este parámetro es un número entero que indica la fila en la que se encuentra la celda.
	\item \verb|col|: Este parámetro es un número entero que indica la columna en que se encuentra la celda
	\item \verb|height|: Este parámetro es un número entre 0 y 1 que indica la altura de la casilla. En dependencia de este parámetro la casilla será terrestre o marina.
	\item \verb|bs_object|: Este parámetro hace referencia al objeto que se encuentra en la casilla. Si en la casilla no se encuentra ningún objeto entonces este parámetro es \verb|None|.
\end{itemize}

El mapa para una simulación se crea instanciando una clase \verb|LandMap| con los siguientes argumentos:

\begin{itemize}
	\item Número de filas $m$
	\item Número de columnas $n$
	\item Un array bidimensional de $m$ filas por $n$ columnas tal que cada posición $i,j$ del array es un número entre 0 y 10 que indica cuan accesible es la celda $i,j$
	\item Un array bidimensional de $m$ filas por $n$ columnas tal que cada posición $i,j$ del array es un número entre 0 y 1 que indica la altura de celda $i,j$
	\item Un número entre 0 y 1 que indica el nivel del mar. Todas las celdas cuya altura sea menor a este número serán consideradas como celdas marinas y todas las celdas superior a este número serán consideradas terrestres.
\end{itemize}

\subsubsection{Generación aleatoria de mapas}

La representación abstracta de un mapa es una matriz de alturas, o sea, una matriz de valores en el intervalo $[0,1]$, donde la noción de nivel del mar es 0.45, o sea, todo valor $x > 0.45$ es una elevación y todo valor $x < 0.45$ es una depresión cubierta por agua. Es importante poder generar un mapa de alturas con un porcentaje de relieve determinado por el usuario que sea lo más realista posible pero esto de forma aleatoria. Por tal razón queda totalmente descartado el enfoque que va por generar una matriz $M$ donde $M[i,j]$ es un número totalmente al azar, pues se obtendrían matrices de ruido similares a la estática en las señales de televisión, además se violaría la restricción del porciento de elevaciones.

\begin{figure}
	\centering
	\includegraphics[width=8cm]{chapters/img/estatica.jpg}
	\caption{Estática en la señal de TV}
\end{figure}

Luego de una consulta bibliográfica, se encontraron algunos procedimientos para la generación de mapas de alturas muy interesantes:

\begin{itemize}
	\item \textbf{Algoritmo de Perlin Noise:} debe su nombre a su creador, Ken Perlin, que durante el rodaje de la película Tron creó el algoritmo con el fin de crear texturas procedimentales para los efectos generados por el ordenador. La idea tras el algoritmo es generar una nueva matriz de dimensión menor a la requerida y superponerla a la requerida escalando de forma que encajen perfectamente. A cada esquina de cada celda de la nueva matriz se le asigna un vector gradiente pseudoaleatorio. Además se determinan los valores offset que representan la posición de cada punto de la matriz original dentro de la celda de la nueva matriz. Luego, para cada esquina de la celda que encierra un punto se determina el vector que va desde ella hasta el punto y se hace el producto escalar de ese vector con el vector gradiente. Se realiza una interpolación lineal entre todos los resultados de los productos escalares y este es el valor del punto. El comportamiento de este algoritmo no puede ser modificado pero aún así fue de gran significación en la época y hoy día.
	\item \textbf{Algoritmo Voronoi:} consiste en dividir el espacio en diagramas de Voronoi, que son, simplemente, particiones de un plano en regiones basadas en la 	distancia a ciertos puntos específicos del plano. Ese conjunto específico de puntos 	se denomina ``semillas, sitios o generadores''. Se suelen especificar de antemano y 	para cada uno de estos sitios se genera una región del plano que consiste en todos 	los puntos que están más cerca de este sitio que de ningún otro. 
	\item \textbf{Algoritmo de cortes:} tiene un comportamiento poco intuito pero interesante, se selecciona un corte en la matriz, se define como corte una linea recta que divida el plano o terreno en dos mitades, luego se decide elevar  una de las mitades y bajar o no modificar las otras. Este mismo proceso se repite miles de veces y se obtienen resultados aceptables. El algoritmo es ineficiente, por la cantidad de iteraciones necesarias para obtener buenos resultados.
	\item \textbf{Algoritmos de erosión térmica e hídrica:} algoritmos que simulan los procesos naturales de erosión térmica e hídrica. En el caso de la térmica se fija un valor $T$ que representa el valor a partir del cual se va a erosionar, y se recorre la matriz buscando los puntos que cumplen que la diferencia de altura con sus vecinos es superior a $T$. En dichos puntos el algoritmo resta valor de altura a sus vecinos cuya distancia sea mayor que $T$ de forma que todas las distancias queden menor que $T$. En el caso de la erosión hídrica se define una matriz de agua y una matriz de sedimentos la cual representa un porciento de material que puede ser movido por la erosión. Y se realiza un procedimiento parecido a la erosión térmica.
\end{itemize}

Ahora estos algoritmo generan mapas de alturas con apariencia realista, pero no son suficientes para cumplir las restricciones de relieve. Por tanto, nuestra propuesta es la implementación de un algoritmo evolutivo que genera un mapa de alturas realista y satisfaga la restricción anteriormente mencionada.

Los algoritmos evolutivos son estrategias de optimización y búsqueda de soluciones que toman como inspiración la evolución en distintos sistemas biológicos. La idea fundamental de estos algoritmos es mantener un conjunto de individuos que representan una posible solución del problema. Estos individuos se mezclan y compiten entre sí, siguiendo el principio de selección natural por el cual sólo los mejor adaptados sobreviven al paso del tiempo. Esto redunda en una evolución hacia soluciones cada vez más aptas. 

El algoritmo evolutivo en cuestión inicia con una población de individuos generados utilizando el algoritmo de Perlin Noise implementado en la biblioteca de Python bajo el nombre \verb|perlin-noise|.	Luego se realizan un cantidad de iteraciones seleccionando los individuos más adaptados, mezclándolos y mutándolos.  Se considera individuo mejor adaptado aquel cuyo valor \verb|fit| sea mayor. Este valor se calcula como sigue:

\begin{verbatim}
def fit_func(self, heightmap: HeightMap):
    count = sum(sum(heightmap.__map__ > self.__sea__))
    per = count / prod(self.__shape__)
    return per if per < self.percentage else 0
\end{verbatim}

Esto es, se cuentan la cantidad de posiciones que su valor de altura supera el nivel del mar, y se calcula el porciento que representan estas del total, si este porciento es superior al porciento de la restricción del problema entonces se le asocia a dicho individo el valor 0.  Por tanto, el valor \verb|fit| máximo que puede tener cualquier individuo es el porciento de la restricción y el menor el 0.

Luego, el proceso de selección de individuos se realiza utilizando el procedimiento de Selección competitiva o por torneos, se seleccionan de la población 4 individuos de forma aleatoria, y se realiza una competencia 2 a 2 seleccionando el mejor en cada pareja y estos son los individuos mejor adaptados. El proceso de mezcla de los individuos seleccionados se realiza utilizando una suma ponderada, con valores 0.95 y 0.05 respectivamente. 

El proceso de mutación del individuo resultante de la mezcla es el siguiente:

\begin{enumerate}
	\item Se genera una matriz temporal \verb|tmp| que representará una matriz de suavizado para la mutación. Esta matriz es una matriz de alturas generada igualmente por el algoritmo de Perlin Noise.
	\item Si el porciento de relieve de la restricción es superior a 0.4 se realiza el procedimiento siguiente:
	\begin{itemize}
		\item La matriz \verb|temp| se multiplica por el escalar -0.3.
		\item La matriz \verb|temp| se suma al individuo proveniente de la mezcla. Dando como resultado un individuo mutado donde de forma general se le baja altura a todas las posiciones.  
	\end{itemize}
	\item Si el porciento de relieve de la restricción es inferior o igual a 0.4 
\end{enumerate}

\subsection{Los objetos}

Un objeto es todo lo que se puede poner el mapa y cada objeto ocupa una y solo una casilla del mapa. Estos tienen propiedades como el id que s único para cada objeto, los puntos de vida que determinan el estado de un objeto y la defensa un parámetro que indica cuan resistente es un objeto a los daños que puede sufrir durante la simulación. Todos estos parámetros son números de 1 a 10. Cuando la vida de un objeto llegue a 0, este se destruye desapareciendo del mapa. Los objetos se clasifican en dos tipos: unidades y objetos estáticos. Los objetos además tienen definidas dos funciones \verb|put_in_cell| cuya función es colocar al objeto en alguna posición de un mapa. Si se intenta poner un objeto en una posición diferente a su tipo este automáticamente se destruye. La otra función \verb|take_damage|, a partir de un ataque sufrido indica como se reducen los puntos de vida del objeto.

\subsubsection{Objetos estáticos}

Los objetos estáticos los podemos definir como objetos propios del ambiente. Estos no pertenecen a ningún bando y no pueden realizar acciones pero si pueden ser afectados por las acciones que realicen las unidades. Estos solo pueden ser puestos en celdas terrestres. Ejemplos de estos objetos pueden ser árboles, rocas, muros, etc. Todos estos objetos son terrestres. 

\subsubsection{Unidades}

Las unidades son los agentes de la simulación. El objetivo de cada una de las unidades es destruir a las unidades enemigas (las que no pertenecen a su mismo bando), y para ello podrá analizar parte del ambiente en el que se encuentra y tomar la decisión que sea más conveniente según sean las circunstancias. 

Dado que el ambiente estará cambiando constantemente, las unidades serán agentes casi puramente reactivos. La arquitectura empleada para definir el comportamiento de las unidades es la Arquitectura de Brooks (de categorización o inclusión) que recordemos tiene las siguientes características: 

\begin{itemize}
	\item La toma de decisión se realiza a través de un conjunto de comportamientos para lograr objetivos (reglas de la forma situación $\rightarrow$ acción).
	\item Las reglas pueden dispararse de manera simultánea por lo que debe un mecanismo para escoger entre ellas.	
\end{itemize}

Dado esto se definió un sistema experto que actuará como la función del agente. Este será descrito posteriormente.

\textbf{Propiedades de las unidades}

Las unidades además de las descritas anteriormente que tienen todos los objetos cuentan con las siguientes propiedades:

\begin{itemize}
	\item \verb|side|: Una instancia de la clase \verb|Side| que indica el bando al que pertenece la unidad
	\item \verb|attack|: Valor entre 1 y 10 que marca la capacidad de causar daños a sus oponentes.
	\item \verb|moral|: Valor entre 1 y 10 que marca la moral con la unidad encara la batalla. Cuanto mayor es ese valor más efectivos son sus ataques y sus defensas.
	\item \verb|ofensive|: Valor entre 1 y 10 que indica cuan ofensiva es una unidad. Un valor alto la hace más ofensiva y un valor bajo la hace más defensiva.
	\item \verb|min_range|: Valor entero entre 0 y 10 que indica el rango mínimo al que se debe encontrar un enemigo para que la unidad pueda atacarlo.
	\item \verb|max_range|: Valor entero entre 0 y 10 que indica el rango máximo al que se debe encontrar un enemigo para que la unidad pueda atacarlo.
	\item \verb|radio|: Valor entero entre 1 y 9 que indica el número de casillas que son afectadas por un ataque de la unidad. Si es 1 se afecta solo a la casilla seleccionada para el ataque. Si es 9 se afectan la casilla seleccionada y las 8 adyacentes a esta. Si es 1 $<$ \verb|radio| $<$ 9, entonces se toman como casillas afectadas la seleccionada y $\verb|radio|-1$ casillas adyacentes a esta.
	\item \verb|vision| : Valor entre 1 y 10 que indica la cantidad de celdas en una determinada dirección, que la unidad puede ``ver'' (saber que objetos están en dicha celda).   
	\item \verb|intelligence|: Valor entre 0 y 10 que indica la inteligencia de la unidad. Mientras más inteligente sea una unidad con mayor precisión puede calcular los atributos de sus enemigos.
	\item \verb|recharge_turns|: Turnos que demora la unidad en recargar después de hacer un ataque. Mientras esté recargando la unidad no podrá atacar pero si puede moverse.
	\item \verb|solidarity|: Valor booleano que indica si la unidad es solidaria o no.
	\item \verb|movil|: Valor booleano que indica si la unidad puede desplazarse por el mapa.  
\end{itemize}

\subsubsection{Sistema experto}

A continuación se explicará el sistema experto implementado que actúa como función del agente la cual describe el comportamiento del agente durante un turno.


Lo primero que la función hace es buscar si se existe un enemigo al que se pueda atacar. Para eso primero se comprueba si la unidad no está recargando, si lo está se reduce en uno los turnos que debe esperar para atacar, si no lo está se busca el mejor enemigo para atacar. 
 
El mejor enemigo para atacar se determina de la siguiente forma:
 
Por cada casilla atacable (casilla que se encuentra a una distancia de la unidad entre su rango mínimo y su rango máximo), se chequea si en la casilla hay un enemigo. Si el radio de ataque es mayor que 1 y hay una unidad amiga cerca del enemigo que pudiera verse afectada por el ataque, se ignora este enemigo. Esto se definió así para evitar el daño ocasionado por fuego amigo.
 
Entonces si el enemigo no es ignorado debido a lo anterior, se calcula el costo de atacar al enemigo. Para dicho cálculo la unidad estima la vida y la defensa del enemigo y con estas estimaciones calcula cuantos turnos podría tomarle destruir a dicho enemigo. Mientras mayor sea la inteligencia de la unidad más precisas serán las estimaciones.

Luego de haber analizado todos los enemigos, el seleccionado por la unidad para atacarlo es aquel cuyo costo es menor. Si no se detecta ningún posible enemigo a atacar entonces la unidad no realiza un ataque en el turno.
 
Si la unidad no realiza un ataque, entonces, en caso de que se móvil, chequea si se puede mover a alguna casilla adyacente a la que se encuentra. Esto se hace de la siguiente forma:
 
Se fija un costo en infinito. Luego por cada una de las celdas que la rodean en todos los puntos cardinales posibles (NW, N, NE, W, E, SW, S y SE)ase calcula el costo de moverse a dicha celda, y nos quedamos con la celda cuyo co es el menor. Luego si el menor costo detectado es menor a infinito la unidad se mueve a dicha celda en caso contrario la unidad mantiene su posición. 
 
Ahora veamos como calcular el costo de que una unidad se mueva de una celda a otra.
 
Si la celda nueva es intransitable (tiene el parámetro \verb|passable| en 0), el tipo de la celda es diferente al tipo de la unidad o si en la celda hay algún objeto se devuelve infinito. Estos son todos los casos en los que la unidad no puede moverse a dicha celda. Para las unidades terrestres siola diferencia de alturas entre dosla ltas es muy grande (mayor a 0.3), tampoco pueden avanzar a dicha celda, retornándose infinito. 
 
Entonces en un primer momento se fija el costo en 10 - \verb|passable|/2, de esta manera se premia ir a celdas más transitables. A continuación se comprueba si esa celda está entre las que la unidad recuerda como ya visitadas. Si así es, el coste se incrementará en \verb|passable|/3. Así logramos incentivar que las unidades visiten celdas no visitadas con anterioridad  
  
Ahora se comprueba si la celda se encuentra en zona ``amiga'', es decir, si esa celda es adyacente a alguna celda en la que se encuentre algún compañero de su bando. Si así es y nuestra unidad protagonista es solidaria, el coste se reducirá a la mitad. Si es una zona amiga pero la unidad no es solidaria, el coste solo se reducirá dividiéndose por la raíz cuadrada de 2. De esta manera se incentiva que las unidades tiendan a permanecer en grupo y más cuanto más solidarias son.

Si la celda que se está estudiando es una celda en la que nuestra unidad tendrá al alcance un enemigo, su coste se reducirá en el valor del parámetro \verb|ofensive|  multiplicado por la inversa de la raíz cuadrada de la distancia mínima hasta el enemigo. Además la unidad observa las celdas cercanas a la celda que se está estudiando que estén dentro de su rango de visión. Si detecta que al moverse a dicha celda se encontrará en rango de algún enemigo el costo se aumenta en 1.1 por cada enemigo que pudiera atacar a la unidad. De esta manera se está diciendo que, cuanto más ofensiva sea nuestra unidad, más se aproximará al enemigo, aunque con cierta precaución.

A continuación se hace una breve explicación de las funciones implementadas a las unidades. Además de las   
ya mencionadas, implementadas en ``BSObject'', un agente ``BSUnit'' tiene implementadas las siguientes funciones:

\begin{itemize}
	\item \verb|calculate_distance(self, cell1, cell2) -> int| con la que la unidad calcula la distancia entre dos celda. La distancia se calcula como la cantidad mínima de celdas que tiene recorrer la unidad para ir de una celda a otra.
	\item \verb|nearby_friend(self, cell) -> bool| con la que el agente determina si moviéndose a la celda de entrada estará cerca de un compañero.
	\item \verb|enemy_in_range(self, cell)| con la que la unidad determina si moviéndose a la celda de entrada estará cerca de un compañero.
	\item \verb|in_range_of_enemy(self, cell) -> int| con la que la unidad detecta a los enemigos de que puden atacarla si se mueve a dicha celda.
	\item \verb|move_cost_calculate(self, cell, type) -> float| con la que la unidad calcula el costo de moverse a la celda.
	\item\verb|enemy_cost_calculate(self, enemy) -> float| con la que la unidad calcula el costo de atacar a un determinado enemigo.
	\item \verb|enemy_to_attack(self)| con la que la unidad selecciona, de ser posible, un enemigo para atacarlo.
	\item \verb|take_damage(self, damage)| que es una redefinición del método de ``BSObject'' para tener en cuenta la moral de la unidad.
	\item \verb|attack_enemy(self, enemy)| la cual es la acción de atacar a un enemigo.
	\item \verb|move_to_cell(self, cell)| la cual es la acción de moverse a una celda determinada.
	\item \verb|def turn(self, type)| con la que la unidad determina que hacer durante un turno, el parámetro \verb|type| hace referencia al tipo de celda que la unidad puede visitar.
\end{itemize}

Los métodos \verb|put_in_cell| y \verb|turn| se redefinen en las clases ``LandUnit'' y ``NavalUnit'' haciendo un llamado a las funciones respectivas de ``BSUnit'' pasando ``earth'' y ``water'' al parámetro type respectivamente.

