\section{Battle Script, el lenguaje de dominio específico para ejecutar el proyecto}

El usuario final del proyecto necesita un medio para específicar las condiciones del enfrentamiento a simular, entiéndase cómo son las unidades, los soldados, el mapa, el movimiento de las unidades, etcétera. Para ello se implementó un lenguaje de dominio específico (DSL, por sus siglas en inglés \textit{Domain Specific Language}) con el nombre de Battle Script, que permite la creación de nuevas unidades, la creación de obstáculos, la creación de mapas, la inserción de unidades y obstáculos en el mapa, la creación de bandos, y la ejecucción de la simulación.

\subsection{Gramática}

Se diseñó la siguiente gramática para el lenguaje:

\begin{verbatim}
bs_file ->  classes statements EOF     
    |   EOF                       

classes -> class_def  classes         
    |  class_def                       

statements ->   statement  statements      
        |   statement                       

statement ->    func_def
        |   if_def
        |   while_def
        |   decl  ';' 
        |   assign  ';' 
        |   return_stat  ';' 
        |   'break'    ';'                        
        |   'continue'  ';'                       
        |   expressions ;


func_def ->     'function' return_type NAME '(' params ')' '->' block       
        |   'function' return_type NAME '(' ')' '->' block              

if_def ->   'if' expression '->' block elif_def                             
    |   'if' expression '->' block else_def                             
    |   'if' expression '->' block                                      

elif_def ->     'elif' expression '->' block elif_def                       
        |   'elif' expression '->' block else_def                       
        |   'elif' expression '->' block                                

else_def -> 'else' '->' block                                               

class_def ->    'class' NAME 'is' NAME '->' '{'  constructor functions '}'   
    |       'class' NAME 'is' NAME '->' '{'  constructor '}'                     


functions -> func_def  functions                     
       | func_def                                

constructor -> 'constructor' '(' params ')' '->' '{' attributes '}'              
         | 'constructor' '(' ')' '->' '{'  attributes '}'                 
         | 'constructor' '(' ')' '->' '{' '}'                   


attributes -> attr_def  attributes             
        | attr_def                         

attr_def ->  type 'this' '.' NAME '=' expression ';'          


while_def ->    'while' expression '->' block              

return_type ->  'void'                        
        |   type                          

type ->   'number'        
  |   'bool'          
  |   NAME            

assign -> NAME '=' expression                         

decl ->  type NAME '=' expression                              

return_stmt ->  'return' expression                                      
        |   'return'                                        

block ->     '{' statements '}'   

params ->   type NAME ',' params      
    |  type NAME                  


expressions ->  expression ','  expressions               
        |   expression                                

expression ->   disjunction 'if' disjunction 'else' expression            
        |   disjunction                                                

disjunction ->  conjunction 'or' disjunction                                
        | conjunction                                                   

conjunction ->  inversion 'and' conjunction                                 
        |   inversion                                                   

inversion ->    'not' inversion                                             
        |    comparision                                                


comparision ->  sum compare_par                                            
        |   sum

compare_par ->  'eq' sum                        
        |   'neq' sum                       
        |   'lte' sum                       
        |   'lt' sum                        
        |   'gte' sum                       
        |   'gt' sum                        


sum ->  sum '+' term                            
    |   sum '-' term                            
    |   term 

term -> term '*' factor                         
    |   term '/' factor                         
    |   term '%' factor                         
    |   factor

factor ->   '+' factor
    |   '-' factor
    |   pow

pow ->  primary '^' factor              
    |   primary

primary ->  primary '.' NAME            
    |   primary '(' args ')'        
    |   primary '(' ')'             
    |   atom

args -> expression ',' args
    | expression

atom -> NAME                            
    |   'True'                          
    |   'False'                         
    |   'None'                          
    |   NUMBER                          
    |   list

list -> '[' expressions ']'             
    |   '[' ']'                         
\end{verbatim}

\subsection{Compilador}

% TODO: ESCRIBIR MUELA BISCA DEL COMPILADOR
AQUI VA UNA MUELA BISCA DE CóMO ES EL COMPILADOR A GRANDES RASGOS

\subsection{Tokenizador}

Un Tokenizador, comúnmente llamado Lexer, es un ente encargado de dividir la cadena de texto de entrada del compilador en tokens del alfabeto del lenguaje Battle Script, identificando el tipo del token y envíandolo a la siguiente etapa del proceso de compilación.

Para la implementación del tokenizador fue necesario un sistema de expresiones regulares, una clase para representar un token, así como su tipo y la definición de los tokens del lenguaje, además de la clase propia del tokenizador. 

\subsubsection{Sistema de expresiones regulares}

Una expresión regulares es una definición recursiva de un lenguaje donde $a$ es la expresión regular para $L(a) = \{a\}$ y $\epsilon$ es la expresión regular para $L(\epsilon) = \{\epsilon\}$. Si $s$ y $r$ son expresiones regulares entonces:

\begin{itemize}
    \item $(s)|(r)$ es la expresión regular para la unión de lenguajes $L(s) \cup L(r)$
    \item $(s)(r)$ es la expresión regular para la concatenación de lenguajes $L(s)L(r)$
    \item $(s)*$ es la expresión regular para la clausura del lenguaje $L(s)* = \bigcup\limits_{k=0}^{\infty} L(s)^k$
\end{itemize}

Se implementó un sistema de expresiones regulares que admite los siguientes operadores:

\begin{itemize}
    \item $|$ que hace la unión de dos expresiones regulares.
    \item La concatenación de expresiones regulares de la siguiente forma, si $a$ y $b$ son expresiones regulares entonces $ab$ es la expresión de la concatenación.
    \item $*$ que hace la clausura del lenguaje que representa la expresión regular.
    \item $?$ que busca la coincidencia de la expresión regular una vez o ninguna.
    \item $+$ que busca la coincidencia de la expresión regular una o más veces.
    \item $.$ que busca la coincidencia de cualquier caracter.
    \item $\setminus$  que permite la inclusión de los operadores anteriores en un expresión regular como un caracter.
\end{itemize}

La gramática para el lenguaje de las expresiones regulares que se implementó es la siguiente:

\begin{verbatim}
    regex = exp 

    exp      = term '|' exp    
            | term

    term     = factor term       
            | factor

    factor   = primary '*'      
            | primary '+'       
            | primary '?'       
            | primary

    primary  = '(' exp ')'
            | '\' CHAR              
            | CHAR
            | '.'
\end{verbatim}

Una expresión regular en el sistema se implementó utilizando la clase \verb|Regex| de Python. Una expresión regular se construye con la cadena de texto que representa el patrón de la expresión regular. Este patrón se compila y se devuelve un Autómata Finito No Determinista que se utiliza para los procesos de saber si una cadena pertenece al lenguaje representado por la expresión, o encontrar todas las coincidencias de la expresión en una cadena de texto. 

\begin{verbatim}
class Regex:
        def __init__(self, pattern: str):
            self.pattern : str = pattern
            self.nfa : NFA = self.compile()
    
        def compile(self) -> NFA:
            lex: Lexer = Lexer(self.pattern)
            parser : Parser = Parser(lex)
            tokens : List[Token] = parser()
            handler: Handler = Handler()
            
            nfa_stack : List[NFA]= []
            
            for t in tokens:
                handler.handlers[t.name](t, nfa_stack)
            
            if len(nfa_stack) == 1:
                return nfa_stack.pop() 
            raise Exception("Bad regex!")
    
        def match(self, string: str) -> bool:
            return self.nfa.match(string)
    
        def find_all(self, string: str) -> List[Match]:
            return self.nfa.find_all(string)
\end{verbatim}

El proceso de compilación de una expresión regular es bastante sencillo, se tiene un tokenizador que recorre la cadena y cada vez que encuentra un operador o un caracter devuelve el token correspondiente, si encuentra el operador de escape ($\setminus$) devuelve un token de tipo \verb|CHAR| con el caracter siguiente. El proceso de Parsing consiste en recibir el conjunto de tokens provenientes del tokenizador y llamar al método \verb|exp| que este parsea el no terminal del mismo nombre de la gramática y va parseando el resto de no terminales según corresponda, o sea, se implementó un Parsing Recursivo Descendente.

Luego del proceso de parsing y verificar que la secuencia de tokens es correcta, se recorre la secuencia de tokens y haciendo uso de la clase \verb|Handler| se construye el autómata de la expresión regular. 

La clase \verb|Handler| es la encargada de dado un conjunto de tokens construir el autómata correspondiente, para ello implementa un método para cada operador de la gramática, estos métodos saben construir el autómata que resulta de aplicar la operación a uno, dos o más autómatas según el operador.

\begin{itemize}
        \item Reconcimiento de un caracter:
        \item Operación de Unión:
        \item Operación de Concatenación:
        \item Operación \verb|*|:
        \item Operación \verb|+|:
        \item Operación \verb|.|:
        \item Operación \verb|?|:
\end{itemize}


